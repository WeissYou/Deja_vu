C51 COMPILER V9.59.0.0   ADC                                                               11/23/2018 19:11:28 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE ADC
OBJECT MODULE PLACED IN ADC.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ADC\ADC.c OPTIMIZE(8,SPEED) INCDIR(.\ADC;.\Deja_vu;.\Global;.\interrupt;
                    -.\Main;.\Motor;.\PWM;.\Timer;.\USART;..\DC_motors) DEBUG OBJECTEXTEND PRINT(.\ADC.lst) TABS(2) OBJECT(ADC.obj)

line level    source

   1          #include"GLOBAL.H"
   2          #include"USART.H"
   3          #include<ADC.H>
   4          
   5          /*----------------------------
   6          初始化ADC
   7          ----------------------------*/
   8          void ADC_init(void)
   9          {
  10   1          P1ASF = 0xff;                   //设置P1为ADC引脚
  11   1          ADC_RES = 0;                    //清除结果寄存器
  12   1          ADC_CONTR = ADC_POWER | ADC_SPEEDLL | ADC_START | channel;
  13   1          Delay(2);                       //ADC上电并延时
  14   1        
  15   1      }
  16          
  17          //软件查询方式
  18          /*----------------------------
  19          发送ADC结果到PC
  20          ----------------------------*/
  21          void ADCResult_showing(uchar channel)
  22          {
  23   1          Data_sending(adc[channel]);     //显示ADC高8位结果
  24   1      }
  25          
  26          /*----------------------------
  27          读取ADC结果
  28          ----------------------------*/
  29          void ADCResult_getting(void)
  30          {
  31   1          ADC_CONTR = ADC_POWER | ADC_SPEEDLL | channel | ADC_START;
  32   1          _nop_();                        //等待4个NOP
  33   1          _nop_();
  34   1          _nop_();
  35   1          _nop_();
  36   1          while (!(ADC_CONTR & ADC_FLAG));//等待ADC转换完成
  37   1          ADC_CONTR &= ~ADC_FLAG;         //Close ADC
  38   1        
  39   1          adc[channel] = ADC_RES;    //将ADC结果存入数组相应位
  40   1          //Data_sending(ADC_RES);  //读取高8位结果并发送到串口
  41   1        
  42   1          if(++channel > 7)
  43   1          channel = 0;  //切换到下一个通道
  44   1          ADC_CONTR = ADC_POWER | ADC_SPEEDLL | ADC_START | channel;  
  45   1      }
  46           
  47          /*----------------------------
  48          ADC数据处理
  49          ----------------------------*/
  50          void Data_processing(void) 
  51          {   
  52   1        uchar i = 0;
  53   1        situation=0x00;
  54   1        for(i = 0; i <8 ; i++)
C51 COMPILER V9.59.0.0   ADC                                                               11/23/2018 19:11:28 PAGE 2   

  55   1        {
  56   2          if(adc[i]>=gray[i])
  57   2          {
  58   3            situation|=(0x01<<i);
  59   3          }
  60   2          else
  61   2          {
  62   3            situation&=(~(0x01<<i));
  63   3          }
  64   2        }
  65   1        /*
  66   1        if(adc[channel] >= gray[channel])        //若采样值大于一临界值
  67   1          daten = 1;                       //判定为1
  68   1        else                             //否则
  69   1          daten = 0;                       //判定为0
  70   1        
  71   1        for(i = 0; i <= 7; i++)
  72   1          p1[i] = daten;
  73   1        switch(channel)                    //将处理结果存入数组相应位
  74   1        {
  75   1          case 0:
  76   1          p1[channel] = daten;
  77   1          break;
  78   1        case 1:
  79   1          p1[channel] = daten;
  80   1          break;
  81   1        case 2:
  82   1          p1[channel] = daten;
  83   1          break;
  84   1          case 3:
  85   1          p1[channel] = daten;
  86   1          break;
  87   1        case 4:
  88   1          p1[channel] = daten;
  89   1          break;
  90   1        case 5:
  91   1          p1[channel] = daten;
  92   1          break;
  93   1        case 6:
  94   1          p1[channel] = daten;
  95   1          break;
  96   1        case 7:
  97   1          p1[channel] = daten;
  98   1          break;
  99   1        }
 100   1         
 101   1         situation = p1[0]*1 + p1[1]*2 + p1[2]*4 + p1[3]*8 + p1[4]*16
 102   1               + p1[5]*32 + p1[6]*64 +  p1[7]*128;       //进制转换   
 103   1      */         
 104   1      }
 105          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    138    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.

C51 COMPILER V9.59.0.0   ADC                                                               11/23/2018 19:11:28 PAGE 3   


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
