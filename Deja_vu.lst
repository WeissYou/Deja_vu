C51 COMPILER V9.54   DEJA_VU                                                               11/24/2018 15:44:58 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE DEJA_VU
OBJECT MODULE PLACED IN Deja_vu.obj
COMPILER INVOKED BY: C:\Keil_v4\C51\BIN\C51.EXE Deja_vu\Deja_vu.c OPTIMIZE(2,SPEED) BROWSE INCDIR(.\ADC;.\Deja_vu;.\Glob
                    -al;.\interrupt;.\Main;.\Motor;.\PWM;.\Timer;.\USART;..\DC_motors) DEFINE(DEBUG) DEBUG OBJECTEXTEND PRINT(.\Deja_vu.lst) 
                    -TABS(2) OBJECT(Deja_vu.obj)

line level    source

   1          #include<DEJA_VU.H>
   2          #include"GLOBAL.H"
   3          #include"MOTOR.H"
   4          #include"PWM.H"
   5          #include "stdio.h"
   6          
   7          char history_dir_data[HISTORY_DIR_DATA_SIZE] = { 0x00 };        // 历史方向数据
   8          
   9          // 方向PID参数
  10          const char dir_pid_p = 17;
  11          const char dir_pid_i = 4;
  12          const char dir_pid_d = 5;
  13          
  14          /*******************************************************************************
  15          *                           陈苏阳@2018-11-24
  16          * Function Name  :  Calculate_Motor_Parameters
  17          * Description    :  计算电机参数
  18          * Input          :  None
  19          * Output         :  None
  20          * Return         :  char                返回最终计算出的方向
  21          *******************************************************************************/
  22          char Calculate_Motor_Parameters(void)
  23          {
  24   1          int dir_pid_p_tmp = 0;      // pid比例计算临时存储变量
  25   1          int dir_pid_i_tmp=0;        // pid积分计算临时存储变量
  26   1          int dir_pid_d_tmp = 0;      // pid微分计算临时存储变量
  27   1          char calculate_dir = 0;      // 计算出的最终结果
  28   1          unsigned char i = 0;
  29   1      
  30   1          /****************方向PID*****************/
  31   1          for (i = 0; i < HISTORY_DIR_DATA_SIZE; i++)
  32   1          {
  33   2              // 对历史位置数据积分累加
  34   2              dir_pid_i_tmp += history_dir_data[i];
  35   2          }
  36   1          // 乘以积分系数
  37   1          dir_pid_i_tmp *= dir_pid_i;
  38   1          
  39   1          // 比例结果为当前位置*比例系数
  40   1          dir_pid_p_tmp = history_dir_data[0] * dir_pid_p;
  41   1      
  42   1          // 微分结果为(本次位置-上上次位置(跳过一个,以拉大时间差))*微分系数
  43   1          dir_pid_d_tmp = (history_dir_data[0] - history_dir_data[2]);//*dir_pid_i;
  44   1          
  45   1          // 计算最终结果
  46   1          calculate_dir = dir_pid_p_tmp + dir_pid_i_tmp + dir_pid_d_tmp;
  47   1        
  48   1          // 限位
  49   1          if (calculate_dir > 100)calculate_dir = 100;
  50   1          if (calculate_dir < -100)calculate_dir = -100;
  51   1      
  52   1      
  53   1          /*****************方向对应的电机方向&PWM映射*******************/
C51 COMPILER V9.54   DEJA_VU                                                               11/24/2018 15:44:58 PAGE 2   

  54   1          if (calculate_dir > 0)
  55   1          {
  56   2          
  57   2            if(calculate_dir>50)
  58   2            {
  59   3              // 如果偏的过多,需要使用反转
  60   3              MotorR_setting_auto_dir(100);
  61   3              MotorL_setting_auto_dir(-calculate_dir);
  62   3            }
  63   2            else
  64   2            {
  65   3              // 如果偏的不多,直接减速就可以处理
  66   3              MotorR_setting_auto_dir(100);
  67   3              MotorL_setting_auto_dir(100 - calculate_dir);
  68   3            }
  69   2          }
  70   1          else if (calculate_dir < 0)
  71   1          {
  72   2            
  73   2            if(calculate_dir<-50)
  74   2            {
  75   3              // 如果偏的过多,需要使用反转
  76   3              MotorR_setting_auto_dir(calculate_dir);
  77   3              MotorL_setting_auto_dir(100);
  78   3            }
  79   2            else
  80   2            {
  81   3              // 如果偏的不多,直接减速就可以处理
  82   3              MotorR_setting_auto_dir(100 - (-calculate_dir));
  83   3              MotorL_setting_auto_dir(100);
  84   3            }
  85   2          }
  86   1          else
  87   1          {
  88   2              MotorL_setting_auto_dir(100);
  89   2              MotorR_setting_auto_dir(100);
  90   2          }
  91   1      
  92   1          return calculate_dir;
  93   1      }// End of char Calculate_Motor_Parameters(void)
  94          
  95          
  96          
  97          /*******************************************************************************
  98          *                           陈苏阳@2018-11-24
  99          * Function Name  :  Calculate_Dir
 100          * Description    :  计算方向数据
 101          * Input          :  None
 102          * Output         :  None
 103          * Return         :  None
 104          *******************************************************************************/
 105          char Calculate_Dir(unsigned char sensor_data)
 106          {
 107   1          char Weights[8] = { -3,-2,-1,0,0,1,2,3 };               // 8路寻迹灰度传感器每一位的权重
 108   1          char dir = 0;                                             // 根据权重以及灰度传感器数据计算出的方向
 109   1          unsigned char i = 0;
 110   1          // 计算方向值
 111   1          for (i = 0; i < 8; i++)
 112   1          {
 113   2              // 如果灰度传感器的第i位为1
 114   2              if (sensor_data&(0x01 << i))
 115   2              {
C51 COMPILER V9.54   DEJA_VU                                                               11/24/2018 15:44:58 PAGE 3   

 116   3                  // 方向数值上加上对应位的权重
 117   3                  dir = dir + Weights[i];
 118   3              }
 119   2          }
 120   1          return dir;
 121   1      }// End of char Calculate_Dir(unsigned char sensor_data)
 122          
 123          
 124          
 125          void Deja_vu(void)
 126          {  
 127   1          char Weights[8] = { -3,-2,-1,0,0,1,2,3 };               // 8路寻迹灰度传感器每一位的权重
 128   1          char dir=0;                                             // 根据权重以及灰度传感器数据计算出的方向
 129   1          unsigned char i=0;
 130   1      
 131   1          // 计算方向
 132   1          dir=Calculate_Dir(situation);
 133   1      
 134   1          // 更新历史方向数据
 135   1          for (i = HISTORY_DIR_DATA_SIZE - 1; i > 0; i--)
 136   1          {
 137   2              history_dir_data[i] = history_dir_data[i-1];
 138   2          }
 139   1          history_dir_data[0] = dir;
 140   1      
 141   1          // 小车跑飞(所有传感器全压白线)
 142   1          if (situation == 0x00)
 143   1          {
 144   2              Motors_stop();
 145   2          }
 146   1          // 小车处于起跑线(所有传感器全压黑线)
 147   1          else if(situation ==0xFF)
 148   1          {
 149   2              MotorL_setting_auto_dir(100);
 150   2              MotorR_setting_auto_dir(100);
 151   2          }
 152   1          else
 153   1          {
 154   2              // 计算电机参数并驱动电机
 155   2              Calculate_Motor_Parameters();
 156   2          }
 157   1      
 158   1      
 159   1          // PWM设定生效
 160   1          pwms_enable();         
 161   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    497    ----
   CONSTANT SIZE    =     16    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      8      29
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
